from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
import time
import random
import tkinter as tk
from tkinter import simpledialog, messagebox
import datetime
import re

# --- åˆå§‹åŒ–ç€è¦½å™¨ ---
def init_driver():
    options = webdriver.ChromeOptions()
    options.add_argument("--disable-notifications")
    options.add_argument("--lang=zh-TW")
    options.add_experimental_option("detach", True)
    options.add_argument("--disable-blink-features=AutomationControlled")
    options.add_experimental_option("excludeSwitches", ["enable-automation"])
    service = Service(ChromeDriverManager().install())
    driver = webdriver.Chrome(service=service, options=options)
    return driver

# --- æ‰‹å‹•ç™»å…¥ ---
def manual_login(driver):
    print("è«‹æ‰‹å‹•å®Œæˆç™»å…¥...")
    driver.get("https://www.threads.net/login")
    input("ç™»å…¥å®Œæˆå¾Œè«‹æŒ‰ Enter ç¹¼çºŒ...")

# --- å¾ç¶²å€æŠ“ä½œè€…å¸³è™Ÿ ---
def extract_author_from_url(url):
    match = re.search(r'threads\.net/@([^/]+)', url)
    return match.group(1).lower() if match else None

# --- æ»¾å‹•æŠ“ç•™è¨€ä¸¦åˆ†æ ---
def scroll_and_get_comments(driver, url):
    print("é–‹å§‹æŠ“å–ç•™è¨€...")
    last_height = driver.execute_script("return document.body.scrollHeight")
    no_new_content_count = 0
    max_no_new_content = 10

    comment_ids_set = set()  # ç•™è¨€å…§å®¹åˆ¤æ–·å”¯ä¸€æ€§
    unique_users = set()

    author_username = extract_author_from_url(url)
    print(f"å¾ç¶²å€å–å¾—è²¼æ–‡ä½œè€…ï¼š@{author_username}")

    while True:
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(random.uniform(3.0, 5.0))
        new_height = driver.execute_script("return document.body.scrollHeight")

        try:
            comment_blocks = WebDriverWait(driver, 10).until(
                EC.presence_of_all_elements_located((By.XPATH,
                    '//div[contains(@class, "xrvj5dj") and contains(@class, "xd0jker") and contains(@class, "x1evr45z")]'
                ))
            )

            for block in comment_blocks:
                try:
                    username_elem = block.find_element(By.XPATH, './/a[contains(@href, "/@")]')
                    content_elem = block.find_element(By.XPATH, './/span')
                    username = username_elem.get_attribute("href").split("/@")[-1].split('/')[0].lower()
                    content = content_elem.text.strip()
                    if not content:
                        continue
                    comment_id = f"{username}:{content}"
                    if comment_id not in comment_ids_set:
                        comment_ids_set.add(comment_id)
                        if username != author_username:
                            unique_users.add(f"@{username}")
                except:
                    continue
        except Exception as e:
            print(f"ç•™è¨€æå–éŒ¯èª¤ï¼š{e}")

        print(f"ç›®å‰ç•™è¨€ç¸½æ•¸ï¼ˆå»é‡å…§å®¹ï¼‰ï¼š{len(comment_ids_set)}ï¼Œä¸é‡è¤‡ç•™è¨€å¸³è™Ÿæ•¸ï¼š{len(unique_users)}")

        if new_height == last_height:
            no_new_content_count += 1
            if no_new_content_count >= max_no_new_content:
                print("å·²åˆ°åº•æˆ–ç„¡æ›´å¤šç•™è¨€ï¼Œåœæ­¢æ»¾å‹•ã€‚")
                break
        else:
            no_new_content_count = 0
            last_height = new_height

    return len(comment_ids_set), list(unique_users)

# --- æŠ½ç ---
def draw_winners(user_list):
    root = tk.Tk()
    root.withdraw()

    if not user_list:
        messagebox.showinfo("æŠ½ççµæœ", "ç„¡ç•™è¨€å¸³è™Ÿå¯æŠ½çã€‚")
        return

    count = simpledialog.askinteger("æŠ½çäººæ•¸", f"å…± {len(user_list)} å€‹å¸³è™Ÿï¼Œè«‹è¼¸å…¥è¦æŠ½å‡ºçš„äººæ•¸ï¼š", minvalue=1, maxvalue=len(user_list))
    if count is None:
        messagebox.showinfo("æç¤º", "æŠ½çå·²å–æ¶ˆã€‚")
        return

    winners = random.sample(user_list, count)
    message = "ğŸ‰ æ­å–œä¸­çè€… ğŸ‰\n\n" + "\n".join(winners)
    messagebox.showinfo("æŠ½ççµæœ", message)
    print("\n" + message)

# --- ä¸»ç¨‹å¼ ---
def main():
    root = tk.Tk()
    root.withdraw()
    try:
        driver = init_driver()
        manual_login(driver)

        target_url = simpledialog.askstring("Threads è²¼æ–‡ç¶²å€", "è«‹è¼¸å…¥ Threads è²¼æ–‡ç¶²å€ï¼š")
        if not target_url:
            messagebox.showinfo("æç¤º", "æœªè¼¸å…¥ç¶²å€ï¼Œç¨‹å¼çµæŸã€‚")
            return

        driver.get(target_url)
        WebDriverWait(driver, 30).until(EC.presence_of_element_located((By.TAG_NAME, 'body')))
        time.sleep(7)

        total_comments, unique_users = scroll_and_get_comments(driver, target_url)

        print("\n============== çµ±è¨ˆçµæœ ==============")
        print(f"å¯¦éš›ç•™è¨€ç¸½æ•¸ï¼ˆå»é‡å…§å®¹ï¼‰ï¼š{total_comments}")
        print(f"ä¸é‡è¤‡ç•™è¨€å¸³è™Ÿæ•¸ï¼š{len(unique_users)}")
        print("======================================")

        if unique_users:
            draw_winners(unique_users)
        else:
            print("ç„¡å¯æŠ½çå¸³è™Ÿã€‚")

    except Exception as e:
        print(f"éŒ¯èª¤ï¼š{e}")
        if 'driver' in locals():
            screenshot = f"error_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
            driver.save_screenshot(screenshot)
            print(f"å·²å„²å­˜éŒ¯èª¤æˆªåœ–ï¼š{screenshot}")
    finally:
        input("\næŒ‰ Enter çµæŸ...")
        if 'driver' in locals():
            driver.quit()

if __name__ == "__main__":
    main()
